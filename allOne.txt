tree:
Vertretungen
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ README.md
â”œâ”€â”€ allOne.txt
â”œâ”€â”€ app
â”‚Â Â  â”œâ”€â”€ __pycache__
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ config.cpython-311.pyc
â”‚Â Â  â”‚Â Â  â””â”€â”€ config.cpython-313.pyc
â”‚Â Â  â”œâ”€â”€ actual_load.py
â”‚Â Â  â”œâ”€â”€ actual_loop.py
â”‚Â Â  â”œâ”€â”€ banner.py
â”‚Â Â  â”œâ”€â”€ banner_config.json
â”‚Â Â  â”œâ”€â”€ class_show.py
â”‚Â Â  â”œâ”€â”€ compare.py
â”‚Â Â  â”œâ”€â”€ config.py
â”‚Â Â  â”œâ”€â”€ data
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 1_future
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 2_future
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 3_future
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ actual
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ original
â”‚Â Â  â”‚Â Â  â””â”€â”€ vertretungen
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ lehrer
â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ lehrer_2025-06-23.json
â”‚Â Â  â”‚Â Â      â””â”€â”€ schueler
â”‚Â Â  â”‚Â Â          â””â”€â”€ schueler_2025-06-23.json
â”‚Â Â  â”œâ”€â”€ logs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ actual_load.log
â”‚Â Â  â”‚Â Â  â””â”€â”€ compare.log
â”‚Â Â  â”œâ”€â”€ original_load.py
â”‚Â Â  â”œâ”€â”€ prefill_3_future.py
â”‚Â Â  â”œâ”€â”€ requirements.txt
â”‚Â Â  â”œâ”€â”€ shift.py
â”‚Â Â  â”œâ”€â”€ show.py
â”‚Â Â  â”œâ”€â”€ start_all.sh
â”‚Â Â  â””â”€â”€ templates
â”‚Â Â      â”œâ”€â”€ banner_template.html
â”‚Â Â      â”œâ”€â”€ class_template.html
â”‚Â Â      â”œâ”€â”€ student_template.html
â”‚Â Â      â””â”€â”€ teacher_template.html
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ readme.txt
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ server_mint-akademie.txt
â”œâ”€â”€ tv-keeper
â”‚Â Â  â”œâ”€â”€ Dockerfile
â”‚Â Â  â””â”€â”€ keep-tv-on.sh
â””â”€â”€ webuntis-crontab


.env:
# WebUntis-Zugangsdaten
WEBUNTIS_SERVER=kephiso.webuntis.com
WEBUNTIS_SCHOOL=hmg-kÃ¶ln
WEBUNTIS_USER=Webuntis
WEBUNTIS_PASSWORD=rzGd4wQ8Ln
OFFSET_DAYS=35


Dockerfile:
FROM python:3.11-slim

ENV TZ=Europe/Berlin
RUN apt-get update \
 && DEBIAN_FRONTEND=noninteractive apt-get install -y tzdata cron curl \
 && ln -fs /usr/share/zoneinfo/$TZ /etc/localtime \
 && dpkg-reconfigure --frontend noninteractive tzdata \
 && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY app/ /app/               # inkl. templates/!
COPY requirements.txt /app/
RUN pip install --no-cache-dir -r requirements.txt

COPY webuntis-crontab /etc/cron.d/webuntis-crontab
RUN chmod 0644 /etc/cron.d/webuntis-crontab \
 && crontab /etc/cron.d/webuntis-crontab

RUN mkdir -p /app/logs \
 && chmod +x /app/start_all.sh

CMD ["/app/start_all.sh"]

HEALTHCHECK --interval=30s --timeout=5s --start-period=30s --retries=3 \
  CMD curl -f http://localhost:5000/ || exit 1


docker-compose:
version: '3.8'
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    restart: unless-stopped
    env_file:
      - ./.env
    volumes:
      - ./app:/app
    ports:
      - "8080:5000"   # â†’ SchÃ¼ler + Lehrer + Stundenplan
      - "5010:5010"   # â†’ Banner-Editor/API
    depends_on:
      - tv-keeper

  tv-keeper:
    build:
      context: ./tv-keeper
      dockerfile: Dockerfile
    privileged: true
    devices:
      - /dev/vchiq:/dev/vchiq
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL","echo 'on 0' | cec-client -s -d 1"]
      interval: 1m
      timeout: 10s
      retries: 3


.gitignore:
# Virtuelle Umgebungen
venv/
app/venv/

# Environment-Files mit Secrets
.env
app/config.env

# Logs & Daten (werden extern gemountet)
app/logs/
app/data/

# Python Cache & Temp
__pycache__/
*.pyc
*.swp

# IDE & Git selbst
.vscode/
.git/


.dockerignore:
# â”€ Python Cache & Venv
**/__pycache__/
**/*.pyc
venv/
app/venv/

# â”€ Gemountete Logs & Daten
app/logs/
app/data/

# â”€ Secrets / Env
.env
app/config.env

# â”€ IDE & Git
.git
.vscode/


README.md:
# Vertretungsplan + TV-Keeper

Dieses Repository enthÃ¤lt zwei Dockerized-Services:

1. **vertretungen_app**  
   - Flask-Webservice fÃ¼r SchÃ¼ler- & Lehrer-VertretungsplÃ¤ne  
   - LÃ¤dt via WebUntis-API aktuelle und zukÃ¼nftige StundenplÃ¤ne  
   - Cron-Jobs fÃ¼r regelmÃ¤ÃŸige Updates  
   - Banner-Anzeige per JSON-Config

2. **tv-keeper**  
   - HÃ¤lt per HDMI-CEC den TV wach  
   - LÃ¤uft als Side-Car und stellt sicher, dass der Bildschirm nicht in Standby geht

## Voraussetzungen

- Docker & Docker Compose  
- Raspberry Pi mit `/dev/vchiq` fÃ¼r CEC-Zugriff

## Installation

1. Kopiere `.env.example` zu `.env` und fÃ¼lle die WebUntis-Zugangsdaten aus.
2. Erstelle `banner_config.json` mit gewÃ¼nschtem Banner-Text/Modus.
3. Starte alle Services:

   ```bash
   docker-compose up --build -d


# MINT-Akademie â€“ Vertretungsplan

## ğŸš€ Projektstart

```bash
cp .env.example .env
docker-compose up -d --build


requirements.txt:
flask
webuntis
python-dotenv


webuntis-crontab:
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
TZ=Europe/Berlin

# 1) alle 3 Min.: aktuelle WebUntis-Daten â†’ /app/data/actual
*/3 * * * *  root  cd /app && python3 actual_load.py       >> /app/logs/actual_load.log 2>&1

# 2) alle 3 Min.: actual vs. original vergleichen â†’ /app/data/vertretungen
*/3 * * * *  root  cd /app && python3 compare.py           >> /app/logs/compare.log    2>&1

# 3) tÃ¤glich 07:30: File-Rotation & Sortieren
30 7 * * *    root  cd /app && python3 shift.py             >> /app/logs/shift.log      2>&1

# 4) tÃ¤glich 07:35: frische Originaldaten
35 7 * * *    root  cd /app && python3 original_load.py     >> /app/logs/original_load.log 2>&1


app/templates/*:
banner:
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Banner-Konfiguration</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    label { margin-right: 20px; }
    textarea { width: 100%; height: 80%; margin-top: 10px; }
    button { margin-top: 5px; padding: 8px 16px; }
  </style>
</head>
<body>
  <h2>Banner konfigurieren</h2>
  <form method="post">
    <label>
      <input type="radio" name="mode" value="none" {% if mode=='none' %}checked{% endif %}>
      Kein Text
    </label>
    <label>
      <input type="radio" name="mode" value="text" {% if mode=='text' %}checked{% endif %}>
      Text
    </label>
    <br>
    <textarea name="text" placeholder="Bannertext hier eingeben...">{{ text }}</textarea>
    <br>
    <button type="submit">Speichern</button>
  </form>
</body>
</html>
class:
<!DOCTYPE html>
<html>
<head>
    <title>Stundenplan</title>
    <meta http-equiv="refresh" content="{{ refresh_interval }}">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            width: 95vw;
            height: 95vh;
            overflow: hidden;
        }
        .banner, .fallback-title {
            text-align: center;
            font-size: 2.5vw;
            font-weight: bold;
            padding: 10px;
        }
        table {
            width: 95%;
            height: 75%;
            border-collapse: collapse;
            font-size: 1.3vw;
            margin: 0 auto;
        }
        th, td {
            border: 1px solid #333;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #0074D9;
            color: white;
        }
    </style>
    <script>
        const groups = {{ groups | safe }};
        const currentGroup = "{{ current_group }}";
        let currentIndex = groups.indexOf(currentGroup);

        function rotate() {
            currentIndex = (currentIndex + 1) % groups.length;
            const nextGroup = groups[currentIndex];
            window.location.href = "/?group=" + encodeURIComponent(nextGroup);
        }

        setInterval(rotate, 10000);
    </script>
</head>
<body>
    <div class="fallback-title">Stundenplan fÃ¼r: {{ current_group }}</div>
    <table>
        <tr>
            <th>Zeit</th>
            {% for class_name in class_names %}
            <th>{{ class_name }}</th>
            {% endfor %}
        </tr>
        {% for time_slot in time_slots %}
        <tr>
            <td>{{ time_slot }}</td>
            {% for class_name in class_names %}
            <td>
                {% for entry in class_data.get(class_name, []) %}
                    {% if entry['Start'] + ' - ' + entry['End'] == time_slot %}
                        {{ entry['Subject'] }} ({{ entry['Room'] }})<br>
                    {% endif %}
                {% endfor %}
            </td>
            {% endfor %}
        </tr>
        {% endfor %}
    </table>
</body>
</html>
student:
<!doctype html>
<html><head><meta charset="utf-8">
<meta http-equiv="refresh" content="60">
<title>SchÃ¼ler-Vertretungen</title>
<style>
  body { margin:0; font-family:sans-serif; }
  #table-container {
    height: calc(100vh - 10vh);
    overflow-y: auto;
    padding: 10px;
    padding-bottom: 20vh;
  }
  table {
    width: 95%;
    border-collapse: collapse;
    font-size: 1.5vw;
    margin: 0 auto;
  }
  th, td {
    border: 1px solid #333;
    padding: 8px;
    text-align: center;
  }
  th {
    background: #0066CC;
    color: #fff;
  }
  #banner {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 10vh;
    border-top: 1px solid #444;
    padding: 8px;
    background: #e0e0e0;
    font-size: 8vh;
    line-height: 10vh;
    text-align: center;
    color: red;
    overflow: hidden;
    white-space: nowrap;
  }
  .signature {
    text-align: right;
    font-size: 1vw;
    color: #666;
    margin-top: 1em;
  }
  .footer-spacer {
    height: 10vh;
  }
</style>
</head><body>
  <div id="table-container">
    <h2>Vertretungen am {{ today }}</h2>
    <table>
      <tr><th>Klasse</th><th>Stunde</th><th>Raum</th><th>Fach</th><th>Lehrer</th></tr>
      {% for kl, periods in data.items() %}
        {% for p in periods %}
        <tr>
          <td>{{ kl }}</td>
          <td>{{ p.start }}â€“{{ p.end }}</td>
          <td>{{ p.rooms|join(", ") }}</td>
          <td>{{ p.subjects|join(", ") }}</td>
          <td>{{ p.teachers|join(", ") }}</td>
        </tr>
        {% endfor %}
      {% endfor %}
    </table>
    <div class="signature">@Nargang</div>
    <div class="footer-spacer"></div>
  </div>

  <div id="banner">
    {% if banner.mode=='text' %}{{ banner.text }}{% endif %}
  </div>

  <script>
    const speed = 50;
    const step = 1;
    const pause = 2000;
    const container = document.getElementById('table-container');
    let scrolling = true;

    function scrollStep() {
      if (!scrolling) return;
      container.scrollBy(0, step);
      if (container.scrollTop + container.clientHeight >= container.scrollHeight) {
        scrolling = false;
        setTimeout(() => {
          container.scrollTo({ top: 0, behavior: 'smooth' });
          setTimeout(() => scrolling = true, 500);
        }, pause);
      }
    }

    setInterval(scrollStep, speed);
  </script>
</body></html>
teacher:
<!doctype html>
<html><head><meta charset="utf-8">
<meta http-equiv="refresh" content="60">
<title>Lehrer-Vertretungen</title>
<style>
  body { margin:0; font-family:sans-serif; }
  #table-container {
    height: calc(100vh - 10vh);
    overflow-y: auto;
    padding: 10px;
    padding-bottom: 20vh;
  }
  table {
    width: 95%;
    border-collapse: collapse;
    font-size: 1.5vw;
    margin: 0 auto;
  }
  th, td {
    border: 1px solid #333;
    padding: 8px;
    text-align: center;
  }
  th {
    background: #CC6600;
    color: #fff;
  }
  #banner {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 10vh;
    border-top: 1px solid #444;
    padding: 8px;
    background: #e0e0e0;
    font-size: 8vh;
    line-height: 10vh;
    text-align: center;
    color: red;
    overflow: hidden;
    white-space: nowrap;
  }
  .signature {
    text-align: right;
    font-size: 1vw;
    color: #666;
    margin-top: 1em;
  }
  .footer-spacer {
    height: 10vh;
  }
</style>
</head><body>
  <div id="table-container">
    <h2>Vertretungen am {{ today }}</h2>
    <table>
      <tr><th>Lehrer</th><th>Stunde</th><th>Raum</th><th>Klasse</th><th>Fach</th></tr>
      {% for row in rows %}
      <tr>
        <td>{{ row.teacher }}</td>
        <td>{{ row.start }}â€“{{ row.end }}</td>
        <td>{{ row.rooms|join(", ") }}</td>
        <td>{{ row.klasse }}</td>
        <td>{{ row.subjects|join(", ") }}</td>
      </tr>
      {% endfor %}
    </table>
    <div class="signature">@Nargang</div>
    <div class="footer-spacer"></div>
  </div>

  <div id="banner">
    {% if banner.mode=='text' %}{{ banner.text }}{% endif %}
  </div>

  <script>
    const speed = 50;
    const step = 1;
    const pause = 2000;
    const container = document.getElementById('table-container');
    let scrolling = true;

    function scrollStep() {
      if (!scrolling) return;
      container.scrollBy(0, step);
      if (container.scrollTop + container.clientHeight >= container.scrollHeight) {
        scrolling = false;
        setTimeout(() => {
          container.scrollTo({ top: 0, behavior: 'smooth' });
          setTimeout(() => scrolling = true, 500);
        }, pause);
      }
    }

    setInterval(scrollStep, speed);
  </script>
</body></html>


app/*:
actual_load.py:
#!/usr/bin/env python3
"""
LÃ¤dt den Stundenplan von heute aus WebUntis und speichert ihn unter
data/actual/<klasse>_<YYYY-MM-DD>.json ab.
"""
import json
import logging
import sys
import os
from datetime import date
from pathlib import Path
from dotenv import load_dotenv
import webuntis

# â”€â”€â”€ Basispfad & Env â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BASEDIR = Path(__file__).parent
load_dotenv(dotenv_path=BASEDIR.parent / ".env")

SERVER = os.getenv("WEBUNTIS_SERVER")
USERNAME = os.getenv("WEBUNTIS_USER")
PASSWORD = os.getenv("WEBUNTIS_PASSWORD")
SCHOOL = os.getenv("WEBUNTIS_SCHOOL")

# â”€â”€â”€ Zielverzeichnis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TARGET_DIR = BASEDIR / "data" / "actual"
TARGET_DIR.mkdir(parents=True, exist_ok=True)

# â”€â”€â”€ Logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)


def login():
    session = webuntis.Session(
        server=SERVER,
        username=USERNAME,
        password=PASSWORD,
        school=SCHOOL,
        useragent="ActualLoadBot/1.0",
    )
    session.login()
    logging.info("âœ” WebUntis Login erfolgreich")
    return session


def extract_list(obj_list):
    names = [getattr(o, "name", None) for o in (obj_list or [])]
    return [n for n in names if n] or ["Unbekannt"]


def save_timetable(session, klass, dt):
    table = session.timetable(klasse=klass, start=dt, end=dt)
    if not table:
        logging.warning(f"Keine EintrÃ¤ge fÃ¼r {klass.name} am {dt}")
        return
    out = []
    for p in table:
        out.append(
            {
                "start": p.start.strftime("%H:%M"),
                "end": p.end.strftime("%H:%M"),
                "subjects": extract_list(getattr(p, "subjects", [])),
                "teachers": extract_list(getattr(p, "teachers", [])),
                "rooms": extract_list(getattr(p, "rooms", [])),
                "info": getattr(p, "code", None) or getattr(p, "info", None),
            }
        )
    fn = f"{klass.name.lower().replace(' ', '')}_{dt.isoformat()}.json"
    fp = TARGET_DIR / fn
    fp.write_text(json.dumps(out, ensure_ascii=False, indent=2), encoding="utf-8")
    logging.info(f"âœ” Gespeichert: {fp}")


def main():
    heute = date.today()
    try:
        with login() as session:
            for klass in session.klassen():
                save_timetable(session, klass, heute)
    except Exception as e:
        logging.error(f"Fehler: {e}")


if __name__ == "__main__":
    main()
banner.py:
#!/usr/bin/env python3
import json, os
from flask import Flask, render_template, request, redirect, url_for, jsonify
import config

app = Flask(__name__, template_folder="templates")

def load_cfg():
    try:
        return json.loads(open(config.BANNER_CONFIG_PATH,encoding="utf-8").read())
    except:
        return {"mode":"none","text":""}

def save_cfg(c):
    with open(config.BANNER_CONFIG_PATH,"w",encoding="utf-8") as f:
        json.dump(c,f,ensure_ascii=False,indent=2)

@app.route("/", methods=["GET","POST"])
def edit():
    c = load_cfg()
    if request.method=="POST":
        c["mode"]=request.form["mode"]
        c["text"]=request.form["text"]
        save_cfg(c)
        return redirect(url_for("edit"))
    return render_template("banner_template.html", **c)

@app.route("/banner.json")
def api():
    return jsonify(load_cfg())

if __name__=="__main__":
    app.run(host="0.0.0.0", port=config.PORT_BANNER, debug=config.DEBUG_MODE)
class_show.py:
#!/usr/bin/env python3
import os, json, logging
from flask import Flask, render_template, request
import config

logging.basicConfig(level=logging.INFO,
                    format="[%(asctime)s] %(message)s",
                    datefmt="%Y-%m-%d %H:%M:%S")

app = Flask(__name__, template_folder="templates")

def load_all_data():
    d = {}
    base = config.ACTUAL_DIR
    if not base.is_dir(): return d
    for f in base.glob("*.json"):
        try:
            raw = json.loads(f.read_text(encoding="utf-8"))
        except:
            raw=[]
        cls = f.name.split("_",1)[0]
        d[cls]=[{
            "Start": e.get("start",""),
            "End":   e.get("end",""),
            "Subject": e.get("subjects",[""])[0],
            "Room":    e.get("rooms",[""])[0],
            "Teacher": e.get("teachers",[""])[0]
        } for e in raw]
    return d

def get_groups(data):
    grp={"5":[],"6":[],"7":[],"8":[],"9":[],"10":[],"IFS":[],"EF":[],"Q1":[],"Q2":[]}
    for c in data:
        k=c[:2]
        if k in grp: grp[k].append(c)
        elif c.startswith("IFS"): grp["IFS"].append(c)
        elif c.startswith("EF"):  grp["EF"].append(c)
        elif c.startswith("Q1"):  grp["Q1"].append(c)
        elif c.startswith("Q2"):  grp["Q2"].append(c)
    return {g: v for g,v in grp.items() if v}

@app.route("/")
def show():
    data  = load_all_data()
    groups= get_groups(data)
    keys  = list(groups)
    g     = request.args.get("group", keys[0] if keys else "")
    cls   = groups.get(g,[])
    slots = sorted({f"{e['Start']} - {e['End']}" for ps in data.values() for e in ps})
    return render_template("class_template.html",
                           class_data=data,
                           class_names=cls,
                           time_slots=slots,
                           groups=json.dumps(keys),
                           current_group=g,
                           refresh=config.HTML_REFRESH_SEC)

if __name__=="__main__":
    app.run(host="0.0.0.0", port=config.PORT_ROTATOR, debug=config.DEBUG_MODE)
compare.py:
#!/usr/bin/env python3
"""
Vergleicht ./data/actual/*_<yyyy-mm-dd>.json mit
./data/original/*_<yyyy-mm-dd>.json und schreibt Ã„nderungen nach
data/vertretungen/schueler/schueler_<yyyy-mm-dd>.json
und data/vertretungen/lehrer/lehrer_<yyyy-mm-dd>.json
"""
import json
import logging
from pathlib import Path
from datetime import date

logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)

BASE     = Path("./data")
DIR_ACT  = BASE / "actual"
DIR_ORIG = BASE / "original"
DIR_DIFF = BASE / "vertretungen"
today    = date.today().strftime("%Y-%m-%d")

def load_json(path: Path):
    if not path.exists():
        return []
    return json.loads(path.read_text(encoding="utf-8"))

def period_key(p) -> tuple:
    return (
        p["start"],
        p["end"],
        "|".join(sorted(p.get("rooms", []))),
        "|".join(sorted(p.get("subjects", []))),
        "|".join(sorted(p.get("teachers", []))),
    )

def diff_lists(orig, act):
    orig_map = {period_key(p): p for p in orig}
    act_map  = {period_key(p): p for p in act}
    diffs = []
    # entfallen
    for k, p in orig_map.items():
        if k not in act_map:
            diffs.append({"status": "ENTFÃ„LLT", **p})
    # neu
    for k, p in act_map.items():
        if k not in orig_map:
            diffs.append({"status": "NEU", **p})
    return diffs

def main():
    # 1) Pro Klasse diff erzeugen
    diffs_by_class = {}
    for act_file in sorted(DIR_ACT.glob(f"*_{today}.json")):
        cls = act_file.stem.split("_")[0]
        orig_file = DIR_ORIG / act_file.name
        orig = load_json(orig_file)
        act  = load_json(act_file)
        diffs = diff_lists(orig, act) if orig else []
        diffs_by_class[cls] = diffs
        logging.info("Î” %s â†’ %d", act_file.name, len(diffs))

    # 2) Schueler-Aggregat
    sch_dir = DIR_DIFF / "schueler"
    sch_dir.mkdir(parents=True, exist_ok=True)
    sch_file = sch_dir / f"schueler_{today}.json"
    sch_file.write_text(json.dumps(diffs_by_class, ensure_ascii=False, indent=2), encoding="utf-8")
    logging.info("â†’ %s", sch_file)

    # 3) Lehrer-Aggregat
    lehrer_list = []
    for cls, periods in diffs_by_class.items():
        for p in periods:
            for t in p.get("teachers", []):
                lehrer_list.append({
                    "teacher": t,
                    "klasse": cls,
                    "start": p.get("start"),
                    "end":   p.get("end"),
                    "rooms":    p.get("rooms", []),
                    "subjects": p.get("subjects", []),
                    "status":   p.get("status")
                })
    # sortieren
    lehrer_list.sort(key=lambda x: x["teacher"])
    l_dir = DIR_DIFF / "lehrer"
    l_dir.mkdir(parents=True, exist_ok=True)
    l_file = l_dir / f"lehrer_{today}.json"
    l_file.write_text(json.dumps(lehrer_list, ensure_ascii=False, indent=2), encoding="utf-8")
    logging.info("â†’ %s", l_file)

if __name__ == "__main__":
    main()
config.py:
import os
# app/config.py

# Debug
DEBUG_MODE = False

# Cron-Intervalle (Sekunden)
RELOAD_INTERVAL     = 7.15 * 60   # substitution load
AUTO_RELOAD_PLAN    = 3 * 60      # actual_load etc.

# Verzeichnisse und Pfade
SUBSTITUTION_DIR      = os.path.join(os.path.dirname(__file__), "data", "vertretungen")
BANNER_CONFIG_PATH    = os.path.join(os.path.dirname(__file__), "banner_config.json")

# Webâ€Server-Ports
PORT_STUDENT          = 5000
PORT_TEACHER          = 5001
PORT_ROTATOR          = 5003
PORT_BANNER           = 5010

# HTML Meta-Refresh (per Template genutzt)
HTML_REFRESH_INTERVAL = 60
original_load.py:
#!/usr/bin/env python3
"""
LÃ¤dt den Original-Plan fÃ¼r heute+OFFSET_DAYS und speichert in data/original/.
"""
import json
import logging
import sys
import os
from datetime import datetime, timedelta
from pathlib import Path
from dotenv import load_dotenv
import webuntis

# â”€â”€â”€ Basispfad & Env â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BASEDIR = Path(__file__).parent
load_dotenv(dotenv_path=BASEDIR.parent / ".env")

SERVER = os.getenv("WEBUNTIS_SERVER")
USERNAME = os.getenv("WEBUNTIS_USER")
PASSWORD = os.getenv("WEBUNTIS_PASSWORD")
SCHOOL = os.getenv("WEBUNTIS_SCHOOL")
DAYS = int(os.getenv("OFFSET_DAYS", "35"))

# â”€â”€â”€ Zielverzeichnis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TARGET_DIR = BASEDIR / "data" / "original"
TARGET_DIR.mkdir(parents=True, exist_ok=True)

# â”€â”€â”€ Logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)


def login():
    session = webuntis.Session(
        server=SERVER,
        username=USERNAME,
        password=PASSWORD,
        school=SCHOOL,
        useragent="OrigLoadBot/1.0",
    )
    session.login()
    logging.info("âœ” WebUntis Login erfolgreich")
    return session


def extract_list(obj_list):
    names = [getattr(o, "name", None) for o in (obj_list or [])]
    return [n for n in names if n] or ["Unbekannt"]


def main():
    target = datetime.now() + timedelta(days=DAYS)
    ds = target.date().isoformat()
    try:
        with login() as session:
            for klass in session.klassen():
                table = session.timetable(klasse=klass, start=target, end=target)
                out = []
                for p in table:
                    out.append(
                        {
                            "start": p.start.strftime("%H:%M"),
                            "end": p.end.strftime("%H:%M"),
                            "subjects": extract_list(getattr(p, "subjects", [])),
                            "teachers": extract_list(getattr(p, "teachers", [])),
                            "rooms": extract_list(getattr(p, "rooms", [])),
                            "info": getattr(p, "code", None)
                            or getattr(p, "info", None),
                        }
                    )
                fn = f"{klass.name.lower().replace(' ', '')}_{ds}.json"
                fp = TARGET_DIR / fn
                fp.write_text(
                    json.dumps(out, ensure_ascii=False, indent=2), encoding="utf-8"
                )
                logging.info(f"âœ” {fn}")
    except Exception as e:
        logging.error(f"Fehler: {e}")


if __name__ == "__main__":
    main()
prefill_3_future.py:
#!/usr/bin/env python3
"""
Prefill: LÃ¤dt StundenplÃ¤ne fÃ¼r heute bis heute+OFFSET_DAYS
und speichert sie in data/3_future/<klasse>_<YYYY-MM-DD>.json.
"""
import json
import logging
import sys
import os
from datetime import date, timedelta
from pathlib import Path
from dotenv import load_dotenv
import webuntis

# â”€â”€â”€ Basispfad & Env â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BASEDIR = Path(__file__).parent
load_dotenv(dotenv_path=BASEDIR.parent / ".env")

SERVER = os.getenv("WEBUNTIS_SERVER")
USERNAME = os.getenv("WEBUNTIS_USER")
PASSWORD = os.getenv("WEBUNTIS_PASSWORD")
SCHOOL = os.getenv("WEBUNTIS_SCHOOL")
DAYS = int(os.getenv("OFFSET_DAYS", "35"))

# â”€â”€â”€ Zielverzeichnis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TARGET_DIR = BASEDIR / "data" / "3_future"
TARGET_DIR.mkdir(parents=True, exist_ok=True)

# â”€â”€â”€ Logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)


def extract_list(obj_list):
    names = [getattr(o, "name", None) for o in (obj_list or [])]
    return [n for n in names if n] or ["Unbekannt"]


def main():
    logging.info(f"Starte Prefill fÃ¼r {DAYS} Tage â€¦")
    try:
        with webuntis.Session(
            server=SERVER,
            username=USERNAME,
            password=PASSWORD,
            school=SCHOOL,
            useragent="PrefillBot/1.0",
        ).login() as session:
            klassen = session.klassen()
            for delta in range(DAYS + 1):
                dt = date.today() + timedelta(days=delta)
                ds = dt.isoformat()
                for klass in klassen:
                    table = session.timetable(klasse=klass, start=dt, end=dt)
                    out = []
                    for p in table:
                        out.append(
                            {
                                "start": p.start.strftime("%H:%M"),
                                "end": p.end.strftime("%H:%M"),
                                "subjects": extract_list(getattr(p, "subjects", [])),
                                "teachers": extract_list(getattr(p, "teachers", [])),
                                "rooms": extract_list(getattr(p, "rooms", [])),
                                "info": getattr(p, "code", None)
                                or getattr(p, "info", None),
                            }
                        )
                    fn = f"{klass.name.lower().replace(' ', '')}_{ds}.json"
                    fp = TARGET_DIR / fn
                    fp.write_text(
                        json.dumps(out, ensure_ascii=False, indent=2), encoding="utf-8"
                    )
                    logging.info(f"âœ” {fn}")
    except Exception as e:
        logging.error(f"Fehler: {e}")


if __name__ == "__main__":
    main()
requirements.txt:
flask
webuntis
python-dotenv
shift.py:
#!/usr/bin/env python3
"""
Klassifiziert alle JSON in data/{original,1_future,2_future,3_future} nach Datum.

original:   delta == 0
1_future:   1 <= delta <= 7
2_future:   8 <= delta <= 14
3_future:  15 <= delta <= 21
delta < 0:  lÃ¶schen
delta > 21: unbehandelt
"""
import logging
import shutil
from pathlib import Path
from datetime import date

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
logging.basicConfig(
    level=logging.INFO, format="[%(asctime)s] %(message)s", datefmt="%Y-%m-%d %H:%M:%S"
)

BASE = Path("./data")
DIR_ORIG = BASE / "original"
DIR_F1 = BASE / "1_future"
DIR_F2 = BASE / "2_future"
DIR_F3 = BASE / "3_future"

for d in (DIR_ORIG, DIR_F1, DIR_F2, DIR_F3):
    d.mkdir(parents=True, exist_ok=True)

today = date.today()


def date_from_filename(fname: str) -> date | None:
    """Erwartet <klasse>_YYYY-MM-DD.json"""
    try:
        part = fname.rsplit("_", 1)[1].split(".")[0]
        return date.fromisoformat(part)
    except Exception:
        return None


def relocate(file: Path, target_dir: Path):
    """Verschiebe file nach target_dir"""
    dst = target_dir / file.name
    shutil.move(str(file), str(dst))
    logging.info("â†’ %s -> %s", file.name, target_dir.name)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Hauptprogramm
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
for folder in (DIR_ORIG, DIR_F1, DIR_F2, DIR_F3):
    for f in folder.glob("*.json"):
        dt = date_from_filename(f.name)
        if dt is None:
            logging.warning("UngÃ¼ltiges Datum: %s", f.name)
            continue

        delta = (dt - today).days

        # 1) delta < 0: lÃ¶schen
        if delta < 0:
            f.unlink()
            logging.info("âœ— gelÃ¶scht (veraltet): %s", f.name)
            continue

        # 2) Richtige Zielordner ermitteln
        if delta == 0:
            target = DIR_ORIG
        elif 1 <= delta <= 7:
            target = DIR_F1
        elif 8 <= delta <= 14:
            target = DIR_F2
        elif 15 <= delta <= 21:
            target = DIR_F3
        else:
            # delta > 21: hier nichts tun
            continue

        # 3) Verschieben, falls nÃ¶tig
        if f.parent != target:
            relocate(f, target)

logging.info("Shift-Vorgang abgeschlossen.")
show.py:
#!/usr/bin/env python3
import os
import json
import threading
import time
import logging
from datetime import date
from flask import Flask, render_template, request, redirect, url_for, jsonify

# config values (kannst du auch aus config.py importieren)
PORT_APP       = 5000
HTML_REFRESH   = 60  # Sekunden, <meta http-equiv="refresh">

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
logging.basicConfig(level=logging.INFO,
                    format="[%(asctime)s] %(message)s",
                    datefmt="%Y-%m-%d %H:%M:%S")

app = Flask(__name__, template_folder="templates")
data_lock = threading.Lock()
sub_data   = {}    # Vertretungsdaten

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def load_substitution_data():
    """LÃ¤dt vertretungen (compare.py output) aus data/vertretungen."""
    base  = os.path.join(os.path.dirname(__file__), "data", "vertretungen")
    today = date.today().strftime("%Y-%m-%d")
    out   = {}
    if not os.path.isdir(base):
        logging.warning("Verzeichnis nicht gefunden: %s", base)
        return out

    for fn in os.listdir(base):
        if fn.endswith(f"_{today}.json"):
            klass = fn.split("_")[0]
            path  = os.path.join(base, fn)
            try:
                with open(path, encoding="utf-8") as f:
                    out[klass] = json.load(f)
            except Exception as e:
                logging.error("Fehler beim Laden %s: %s", fn, e)
                out[klass] = []
    return out

def data_reload_loop():
    """Reload alle 3 Minuten."""
    while True:
        logging.info("Reload Vertretungen â€¦")
        new = load_substitution_data()
        with data_lock:
            sub_data.clear()
            sub_data.update(new)
        time.sleep(3 * 60)

# Hintergrund-Thread starten
threading.Thread(target=data_reload_loop, daemon=True).start()

def load_banner_json():
    """Banner-Konfig fresh bei jedem Request."""
    path = os.path.join(os.path.dirname(__file__), "banner_config.json")
    try:
        with open(path, encoding="utf-8") as f:
            return json.load(f)
    except:
        return {"mode":"none","text":""}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  ROUTEN
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@app.route("/")
def student_view():
    """SchÃ¼ler-Vertretungen nach Klasse."""
    with data_lock:
        data = {k: sub_data[k] for k in sorted(sub_data)}
    banner = load_banner_json()
    return render_template("student_template.html",
                           data=data,
                           banner=banner,
                           today=date.today().isoformat(),
                           refresh=HTML_REFRESH)

@app.route("/teacher")
def teacher_view():
    """Lehrer-Vertretungen alphabetisch."""
    with data_lock:
        raw = dict(sub_data)

    # jede Periode pro Lehrer als eigener Eintrag
    rows = []
    for klass, periods in raw.items():
        for p in periods:
            for teacher in p.get("teachers", []):
                rows.append({
                    "teacher": teacher,
                    "start":   p.get("start",""),
                    "end":     p.get("end",""),
                    "classes": klass,
                    "subjects": p.get("subjects",[]),
                    "rooms":   p.get("rooms",[])
                })
    rows.sort(key=lambda r: r["teacher"])
    banner = load_banner_json()
    return render_template("teacher_template.html",
                           rows=rows,
                           banner=banner,
                           today=date.today().isoformat(),
                           refresh=HTML_REFRESH)

@app.route("/timetable")
def timetable_view():
    """Stundenplan-Rotator (class_show.py Logic)."""
    # klassengruppen und Rotation wie vorher
    from class_show import load_all_data, get_class_groups
    class_data = load_all_data()
    group_keys = list(get_class_groups(class_data).keys())
    grp = request.args.get("group", group_keys[0] if group_keys else "")
    if grp not in group_keys: grp = group_keys[0]

    # slot-Header
    class_names = get_class_groups(class_data)[grp]
    slots = sorted({
        f"{e['Start']} - {e['End']}"
        for periods in class_data.values() for e in periods
    })
    return render_template("class_template.html",
                           class_data=class_data,
                           class_names=class_names,
                           time_slots=slots,
                           current_group=grp,
                           groups=json.dumps(group_keys),
                           refresh=10)  # rotiere alle 10s

@app.route("/banner.json")
def banner_api():
    """Reines JSON fÃ¼r Banner-Clients."""
    return jsonify(load_banner_json())

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=PORT_APP, debug=False)
start_all.sh:
#!/usr/bin/env bash
# start_all.sh â€“ Startscript fÃ¼r Vertretungsplan-Projekt

# 0) Fehler sofort anzeigen, wenn ein Befehl fehlschlÃ¤gt
set -e

# 1) Starte den Cron-Dienst fÃ¼r zeitgesteuerte Tasks
echo "[START] Starte cron-Dienst..."
cron

# 2) Starte die SchÃ¼ler-Ansicht (Student-Frontend, Port aus config.py)
echo "[START] Starte SchÃ¼leransicht..."
python3 show.py &

# 3) Starte die Lehrer-Ansicht (Teacher-Frontend, ebenfalls in show.py enthalten)
# (Bereits durch show.py auf anderem Port gestartet)

# 4) Starte die Klassenrotation (klassengruppierte Ansicht)
echo "[START] Starte Klassenrotation..."
python3 class_show.py &

# 5) Starte das Banner-Konfigurationsinterface
echo "[START] Starte Bannereditor..."
python3 banner.py &

# 6) Warte auf alle Kindprozesse, damit der Container nicht beendet wird
wait


Fehlerliste

1. config.py und class_show.py

Variable HTML_REFRESH_SEC wird in class_show.py verwendet, existiert aber in config.py nur als HTML_REFRESH_INTERVAL.

2. show.py Lehrer-Ansicht

In teacher_view wird im rows-Dict-Feld fÃ¼r Klasse der Key classes verwendet, im Template aber klasse abgefragt.

Der Import von get_class_groups heiÃŸt im Modul class_show.py tatsÃ¤chlich get_groups.

3. HTML-Templates (class_template.html)

Das Meta-Refresh-Attribut nutzt refresh_interval, aber class_show.py Ã¼bergibt die Variable refresh.

4. README.md

Codeblock wird nicht korrekt abgeschlossen (fehlendes ``` am Ende).

Hinweis auf .env.example, aber im Repo liegt nur .env.

5. Doppeltes requirements.txt und readme.txt

Zwei requirements.txt in Root und app/ und zusÃ¤tzlich readme.txt. Klare Trennung oder Entfernung nÃ¶tig.